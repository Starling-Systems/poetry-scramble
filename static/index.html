<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Poetry Scramble</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100vh;
        background-color: #f4f4f9;
      }
      h1 {
        color: #333;
      }
      .poem-display {
        margin: 20px 0;
        padding: 20px;
        border: 4px solid black;
        border-radius: 5px;
        background-color: #fff;
        width: 80%;
        display: flex;
        flex-direction: column;
        align-items: center;
        transition: border 0.3s ease-in-out; /* For smoother flashing */
      }
      .line-box {
        padding: 15px;
        margin: 10px;
        border: 1px solid #ccc;
        border-radius: 5px;
        background-color: #e8e8e8;
        width: calc(100% - 40px);
        text-align: center;
        cursor: grab;
        touch-action: none; /* Prevent scrolling during drag */
      }
      .line-box.dragging {
        opacity: 0.5;
      }
      .line-box.over {
        border: 2px dashed #007bff;
      }
      .poem-display.correct {
        border-color: green;
        border-width: 6px;
        animation: flash-border 0.5s alternate infinite;
      }
      .instructions {
        margin-top: 20px;
        padding: 10px;
        font-size: 14px;
        color: #555;
        text-align: center;
      }
      @keyframes flash-border {
        0% {
          border-color: green;
        }
        100% {
          border-color: lightgreen;
        }
      }
    </style>
  </head>
  <body>
    <h1>Poetry Scramble</h1>
    <div id="poemDisplay" class="poem-display">Loading poem...</div>
    <div class="instructions">
      Drag and drop the lines to reorder them. The border will turn green and
      flash when the lines are in the correct order.
    </div>

    <script>
      let originalOrder = [];
      let shuffledOrder = [];

      async function loadRandomPoem() {
        try {
          const randomId = Math.floor(Math.random() * 67) + 1; // Random ID between 1 and 67
          const response = await fetch(`/poem/${randomId}`);
          if (!response.ok) {
            throw new Error("Failed to load poem");
          }
          const poem = await response.json();
          displayRandomLines(poem);
        } catch (error) {
          document.getElementById("poemDisplay").textContent =
            "Error loading poem: " + error.message;
        }
      }

      function displayRandomLines(poem) {
        const lines = poem.lines;
        if (lines.length < 4) {
          document.getElementById("poemDisplay").textContent =
            "Poem has less than 4 lines.";
          return;
        }
        const start = Math.floor(Math.random() * (lines.length - 3)); // Ensure at least 4 lines are available
        originalOrder = lines.slice(start, start + 4);
        shuffledOrder = [...originalOrder];

        // Shuffle the lines
        for (let i = shuffledOrder.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [shuffledOrder[i], shuffledOrder[j]] = [
            shuffledOrder[j],
            shuffledOrder[i],
          ];
        }

        const poemDisplay = document.getElementById("poemDisplay");
        poemDisplay.innerHTML = `
                <h2>${poem.title}</h2>
                <h3>by ${poem.author}</h3>
            `;

        shuffledOrder.forEach((line, index) => {
          const lineBox = document.createElement("div");
          lineBox.classList.add("line-box");
          lineBox.draggable = true;
          lineBox.textContent = line;
          lineBox.dataset.index = index;
          addDragAndDropListeners(lineBox);
          poemDisplay.appendChild(lineBox);
        });
      }

      function addDragAndDropListeners(element) {
        element.addEventListener("dragstart", (e) => {
          e.target.classList.add("dragging");
          e.dataTransfer.setData("text/plain", e.target.dataset.index);
        });

        element.addEventListener("dragend", (e) => {
          e.target.classList.remove("dragging");
        });

        element.addEventListener("dragover", (e) => {
          e.preventDefault();
          const dragging = document.querySelector(".dragging");
          if (dragging && e.target.classList.contains("line-box")) {
            e.target.classList.add("over");
          }
        });

        element.addEventListener("dragleave", (e) => {
          e.target.classList.remove("over");
        });

        element.addEventListener("drop", (e) => {
          e.preventDefault();
          e.target.classList.remove("over");

          const draggingIndex = e.dataTransfer.getData("text/plain");
          const targetIndex = e.target.dataset.index;

          // Swap the lines in the shuffled order
          [shuffledOrder[draggingIndex], shuffledOrder[targetIndex]] = [
            shuffledOrder[targetIndex],
            shuffledOrder[draggingIndex],
          ];

          updateDisplay();
          checkCorrectOrder();
        });

        // For touch events (mobile drag support)
        element.addEventListener("touchstart", (e) => {
          e.target.classList.add("dragging");
          const touchIndex = e.target.dataset.index;
          e.target.dataset.touchStartIndex = touchIndex;
        });

        element.addEventListener("touchmove", (e) => {
          e.preventDefault(); // Prevent scrolling
          const touch = e.touches[0];
          const target = document.elementFromPoint(
            touch.clientX,
            touch.clientY
          );
          const dragging = document.querySelector(".dragging");
          if (
            dragging &&
            target &&
            target.classList.contains("line-box") &&
            target !== dragging
          ) {
            target.classList.add("over");
          }
        });

        element.addEventListener("touchend", (e) => {
          e.target.classList.remove("dragging");
          const touchEndIndex = e.target.dataset.touchStartIndex;
          const overElement = document.querySelector(".line-box.over");
          if (overElement) {
            const targetIndex = overElement.dataset.index;
            overElement.classList.remove("over");

            // Swap the lines in the shuffled order
            [shuffledOrder[touchEndIndex], shuffledOrder[targetIndex]] = [
              shuffledOrder[targetIndex],
              shuffledOrder[touchEndIndex],
            ];

            updateDisplay();
            checkCorrectOrder();
          }
        });
      }

      function updateDisplay() {
        const poemDisplay = document.getElementById("poemDisplay");
        const lineBoxes = Array.from(poemDisplay.querySelectorAll(".line-box"));
        lineBoxes.forEach((box, index) => {
          box.textContent = shuffledOrder[index];
          box.dataset.index = index;
        });
      }

      function checkCorrectOrder() {
        const poemDisplay = document.getElementById("poemDisplay");
        if (JSON.stringify(originalOrder) === JSON.stringify(shuffledOrder)) {
          poemDisplay.classList.add("correct");
        } else {
          poemDisplay.classList.remove("correct");
        }
      }

      window.onload = loadRandomPoem;
    </script>
  </body>
</html>
