<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Poetry Scramble</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        min-height: 100vh;
        background-color: #f4f4f9;
      }
      h1 {
        color: #333;
      }
      .poem-display {
        margin: 20px 0;
        padding: 20px;
        border: 4px solid black;
        border-radius: 5px;
        background-color: #fff;
        width: 80%;
        display: flex;
        flex-direction: column;
        align-items: center;
        transition: border 0.3s ease-in-out;
      }
      .line-box {
        padding: 15px;
        margin: 10px;
        border: 1px solid #ccc;
        border-radius: 5px;
        background-color: #e8e8e8;
        width: calc(100% - 40px);
        text-align: center;
        cursor: grab;
      }
      .line-box.dragging {
        opacity: 0.5;
      }
      .line-box.over {
        border: 2px dashed #007bff;
      }
      .poem-display.correct {
        border-color: green;
        border-width: 6px;
        animation: flash-border 0.5s alternate infinite;
      }
      .ordered-lines {
        margin-top: 20px;
        padding: 10px;
        border: 2px solid #ddd;
        background-color: #f9f9f9;
        width: 80%;
      }
      .instructions {
        margin-top: 20px;
        padding: 10px;
        font-size: 14px;
        color: #555;
        text-align: center;
      }
      @keyframes flash-border {
        0% {
          border-color: green;
        }
        100% {
          border-color: lightgreen;
        }
      }
    </style>
  </head>
  <body>
    <h1>Poetry Scramble</h1>
    <div id="poemDisplay" class="poem-display">Loading poem...</div>
    <div id="orderedLines" class="ordered-lines">
      Ordered lines will appear here.
    </div>
    <div class="instructions">
      Drag and drop the lines to reorder them. The border will turn green and
      flash when the lines are in the correct order.
    </div>

    <script>
      let originalOrder = [];
      let shuffledOrder = [];
      let allLines = [];
      let orderedLines = [];
      let currentIndex = 0;
      const linesPerRound = 4;
      let touchStartIndex = null;

      async function loadRandomPoem() {
        try {
          const randomId = Math.floor(Math.random() * 67) + 1;
          const response = await fetch(`/poem/${randomId}`);
          if (!response.ok) {
            throw new Error("Failed to load poem");
          }
          const poem = await response.json();
          allLines = poem.lines;
          orderedLines = [];
          currentIndex = 0;
          displayNextLines();
        } catch (error) {
          document.getElementById("poemDisplay").textContent =
            "Error loading poem: " + error.message;
        }
      }

      function displayNextLines() {
        const poemDisplay = document.getElementById("poemDisplay");
        const orderedLinesDisplay = document.getElementById("orderedLines");

        if (currentIndex >= allLines.length) {
          poemDisplay.innerHTML =
            "<h2>Congratulations! You've completed the poem!</h2>";
          return;
        }

        originalOrder = allLines.slice(
          currentIndex,
          currentIndex + linesPerRound
        );
        shuffledOrder = [...originalOrder];

        for (let i = shuffledOrder.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [shuffledOrder[i], shuffledOrder[j]] = [
            shuffledOrder[j],
            shuffledOrder[i],
          ];
        }

        poemDisplay.innerHTML = `<h2>Reorder these lines:</h2>`;
        shuffledOrder.forEach((line, index) => {
          const lineBox = document.createElement("div");
          lineBox.classList.add("line-box");
          lineBox.draggable = true;
          lineBox.textContent = line;
          lineBox.dataset.index = index;
          addDragAndDropListeners(lineBox);
          poemDisplay.appendChild(lineBox);
        });

        orderedLinesDisplay.innerHTML = `<h3>Ordered lines:</h3><p>${orderedLines.join(
          "<br>"
        )}</p>`;
      }

      function addDragAndDropListeners(element) {
        // For desktop drag-and-drop
        element.addEventListener("dragstart", (e) => {
          e.target.classList.add("dragging");
          e.dataTransfer.setData("text/plain", e.target.dataset.index);
          e.dataTransfer.effectAllowed = "move";
        });

        element.addEventListener("dragend", (e) => {
          e.target.classList.remove("dragging");
          document
            .querySelectorAll(".line-box.over")
            .forEach((el) => el.classList.remove("over"));
        });

        element.addEventListener("dragover", (e) => {
          e.preventDefault();
          e.dataTransfer.dropEffect = "move";
          const dragging = document.querySelector(".dragging");
          if (
            dragging &&
            e.target.classList.contains("line-box") &&
            e.target !== dragging
          ) {
            e.target.classList.add("over");
          }
        });

        element.addEventListener("dragleave", (e) => {
          e.target.classList.remove("over");
        });

        element.addEventListener("drop", (e) => {
          e.preventDefault();
          const dragging = document.querySelector(".dragging");
          if (!dragging) return;

          const draggingIndex = parseInt(dragging.dataset.index);
          const targetIndex = parseInt(e.target.dataset.index);

          if (
            !isNaN(draggingIndex) &&
            !isNaN(targetIndex) &&
            draggingIndex !== targetIndex
          ) {
            [shuffledOrder[draggingIndex], shuffledOrder[targetIndex]] = [
              shuffledOrder[targetIndex],
              shuffledOrder[draggingIndex],
            ];
          }

          updateDisplay();
          checkCorrectOrder();
        });

        // For mobile touch events
        element.addEventListener("touchstart", (e) => {
          touchStartIndex = parseInt(e.target.dataset.index);
          e.target.classList.add("dragging");
        });

        element.addEventListener("touchend", (e) => {
          const overElement = document.elementFromPoint(
            e.changedTouches[0].clientX,
            e.changedTouches[0].clientY
          );

          if (overElement && overElement.classList.contains("line-box")) {
            const targetIndex = parseInt(overElement.dataset.index);

            if (
              !isNaN(touchStartIndex) &&
              !isNaN(targetIndex) &&
              touchStartIndex !== targetIndex
            ) {
              [shuffledOrder[touchStartIndex], shuffledOrder[targetIndex]] = [
                shuffledOrder[targetIndex],
                shuffledOrder[touchStartIndex],
              ];
            }
          }

          document
            .querySelectorAll(".line-box")
            .forEach((el) => el.classList.remove("dragging"));
          updateDisplay();
          checkCorrectOrder();
        });
      }

      function updateDisplay() {
        const poemDisplay = document.getElementById("poemDisplay");
        const lineBoxes = Array.from(poemDisplay.querySelectorAll(".line-box"));
        lineBoxes.forEach((box, index) => {
          box.textContent = shuffledOrder[index];
          box.dataset.index = index;
        });
      }

      function checkCorrectOrder() {
        const poemDisplay = document.getElementById("poemDisplay");
        if (JSON.stringify(originalOrder) === JSON.stringify(shuffledOrder)) {
          poemDisplay.classList.add("correct");
          orderedLines = orderedLines.concat(originalOrder);
          currentIndex += linesPerRound;
          setTimeout(() => {
            poemDisplay.classList.remove("correct");
            displayNextLines();
          }, 1000);
        } else {
          poemDisplay.classList.remove("correct");
        }
      }

      window.onload = loadRandomPoem;
    </script>
  </body>
</html>
